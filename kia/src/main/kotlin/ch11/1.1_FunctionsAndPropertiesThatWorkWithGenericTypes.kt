package ch11.FunctionsAndPropertiesThatWorkWithGenericTypes

// we can declare extension properties with generic types
val <T> List<T>.penultimate: T
    get() = this[size - 2]

fun main() {
    // list type cannot be inferred. We should specify somehow the type:
    var someEmptyList1 = mutableListOf<String>()
    //or
    var someEmptyList2: List<String> = mutableListOf()

    val letters = ('a'..'z').toList()
    println(letters.slice<Char>(0..2))                      // [a, b, c]
    println(letters.slice(10..13))                          // [k, l, m, n]

    // the compiler substitutes the inferred type Char or Int for T in the function return type
    println(letters.penultimate.uppercase())                     // Y
    println(listOf(1, 2, 3, 4).penultimate)                      // 3

    // the type of the autogenerated lambda parameter it is String in this case. It is the type of the function paramaeter
    // (T) -> Boolean. The compiler understands T is String because it knows the function should be called
    // on List<T> and the actual type of its receiver readers is List<String>
    val authors = listOf("John", "Mary", "Sarah", "Thomas")
    val readers = listOf("Tim", "Harry", "Hannah", "Mary")
    println(readers.filter { it !in authors })                  // [Tim, Harry, Hannah]
}
