## Using `!!` where it's not necessary

``` kotlin
var realm: Realm? = null
var results: RealmResults<T>? = null

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    realm = Realm.getDefaultInstance()

    results = realm!!.where<T>().findAll()
    results!!.addChangeListener { /* ... */ }
    realm!!.addChangeListener { /*...*/ }
}

override fun onDestroy() {
    super.onDestroy()
    realm!!.removeAllChangeListeners()
    realm!!.close()
    realm = null
}
```

could be

``` kotlin
var realm: Realm? = null
lateinit var results: RealmResults<T>

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    val realm = Realm.getDefaultInstance()
    this.realm = realm

    results = realm.where<T>().findAll()
    results.addChangeListener { /* ... */ }
    realm.addChangeListener { /*...*/ }
}

override fun onDestroy() {
    super.onDestroy()
    realm?.removeAllChangeListeners()
    realm?.close()
    realm = null
}
```

## Using `it` in multi-line expression (1.)

``` kotlin
.map {
    Item(
        id = it.id,
        title = it.title,
        timestamp = it.createdAt,
        author = it.user.name
    )
}
```

should be

``` kotlin
.map { photo ->
    Item(
        id = photo.id,
        title = photo.title,
        timestamp = photo.createdAt,
        author = photo.user.name
    )
}
```

## Using `it` in multi-line expression (2.)

``` kotlin
activity?.let {
    sharedViewModel = ViewModelProvider(it).get(SharedViewModel::class.java)
}
```

Prefer to name variables if the lambda is not in the same line.

``` kotlin
activity?.let { activity ->
    val viewModel = ViewModelProvider(activity).get(MyViewModel::class.java)
}
```

Or another option:

``` kotlin
val activity = activity
if(activity != null) { // <-- this enables safe-casting to non-null type
    val viewModel = ViewModelProvider(activity).get(MyViewModel::class.java) 
    ...
}
```

Also note that the `ViewModelProviders.of(activity)` could be moved into an extension function, and the `(MyViewModel::class.java)` could be replaced with `<MyViewModel>()` using `inline fun <reified T: ViewModel>`.


## Nested `it`s

``` kotlin
activity?.let { // it
    val viewModel = ViewModelProviders.of(it).get(MyViewModel::class.java)

    viewModel.inputNumber.observe(this, Observer { // it
        it?.let { // it
            ...
        }
    })
}
```

should be

``` kotlin
val activity = activity
if(activity != null) {
    val viewModel = ViewModelProviders.of(activity).get(MyViewModel::class.java)

    viewModel.inputNumber.observe(viewLifecycleOwner, Observer {
        val number = it ?: return@Observer
        ...
    })
}
```

## Unnecessary chaining of safe-call operator

``` kotlin
activity?.supportFragmentManager
        ?.beginTransaction()
        ?.setCustomAnimations(...)
        ?.replace(...)
        ?.addToBackStack(...)
        ?.commit()
```

should be

``` kotlin
activity?.let { activity ->
    activity.supportFragmentManager
            .beginTransaction(...)
            .setCustomAnimations(...)
            .replace(...)
            .addToBackStack(...)
            .commit()
}
```


## Using var instead of val + assignment

``` kotlin
var input = 0
if (text.toString().isNotEmpty()) {
    input = text.toString().toInt()
}
```

Could be

``` kotlin
val str = text.toString()
val input = when {
    str.isNotEmpty() -> str.toInt()
    else -> 0
}
```

## Assigning to the same value multiple times on different branches (even though there is nothing else in the condition)

``` kotlin
if (p1 == 0) {
    appBar.stateListAnimator =  AnimatorInflater.loadStateListAnimator(context, R.animator.appbar_elevation_disable)
} else {
    appBar.stateListAnimator =  AnimatorInflater.loadStateListAnimator(context, R.animator.appbar_elevation_enable)
}
```

should be

``` kotlin
appBar.stateListAnimator =  AnimatorInflater.loadStateListAnimator(context, when { 
    p1 == 0 -> R.animator.appbar_elevation_disable
    else -> R.animator.appbar_elevation_enable
})
```

## Separation of field declaration and constructor (where the two could be merged)

``` kotlin
class Device_info {
    var id : Int = 0
    var name : String = ""

    constructor(id : Int, name: String){
        this.id = id
        this.name = name
    }
}
```

should be

``` kotlin
class DeviceInfo(
    var id : Int = 0,
    var name : String = ""
) 
```

## Using + to concat strings instead of """

``` kotlin
val createTable = "CREATE TABLE " + TABLE_NAME + "(" + RAW_ID +
       " INTEGER PRIMARY KEY, " + COLUMN_NAME + " TEXT, " +
         COLUMN_ID + "INTEGER)"
```

should be

``` kotlin
val createTable = """CREATE TABLE $TABLE_NAME(
                      $RAW_ID INTEGER PRIMARY KEY, 
                      $COLUMN_NAME TEXT, 
                      $COLUMN_ID INTEGER)"""
```

## Using var instead of val where setter is not required

``` kotlin
class DataBaseHandler(var context: Context) : SQLiteOpenHelper(context, DATABASE_NAME, null, 1) {
```

could be 

``` kotlin
class DatabaseHandler(val context: Context) : SQLiteOpenHelper(context, DATABASE_NAME, null, 1) {
```

## Using nullable platform type where the object is actually not nullable

``` kotlin
override fun onCreate(db: SQLiteDatabase?) {
    db?.execSQL(createTable)
}
```

could be

``` kotlin
override fun onCreate(db: SQLiteDatabase) {
    db.execSQL(createTable)
}
```

## Using "m" prefix for field variables

``` kotlin
var mPosition:Int=adapterPosition
var item:TestCart=mList[mPosition]

when(v!!.id)
{
    deleteButton.id ->
    {
        deleteItem(item.itemId!!)
        mList.removeAt(adapterPosition)
```

could be

``` kotlin
// assume I'm using `.onClick {` instead
val item = itemList[adapterPosition]
deleteItem(item.itemId)
itemList.removeAt(adapterPosition)
```

## Declaring field variables in constructor on the right side of the screen

``` kotlin
class DeviceInfo(var id : Int = 0,
                 var name : String = ""): Entity()
```

could be

``` kotlin
class DeviceInfo(
    var id : Int = 0,
    var name : String = ""
): Entity()
```

## Not using scoping functions where they actually make the code simpler

``` kotlin
var values = ContentValues()
values.put("Title", "Some title")
values.put("Content", "And some content")
```

could be

``` kotlin
val values = ContentValues().apply {
    put("Title", "Some title")
    put("Content", "And some content")
}
```

## Exposing statics to Java through companions

``` java
SomeClass someClass = MyObject.Companion.INSTANCE.getSomeClass();
``` 

should be

``` java
SomeClass someClass = MyObject.SOME_CLASS;
```

with

``` kotlin
class MyObject {
    companion object {
        @JvmField // <-- in some cases, @JvmStatic 
        val SOME_CLASS = SomeClass()
    }
}
```